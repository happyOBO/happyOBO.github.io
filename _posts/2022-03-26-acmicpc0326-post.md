---
title: "[알고리즘] 방탈출"
date: 2022-03-26 21:30:28 -0400
categories: 알고리즘 BFS 완전탐색 C++
---

![[no-alignment]]({{ site.url }}{{ site.baseurl }}/assets/images/post-programmers/111.png){: .align-center}


![[no-alignment]]({{ site.url }}{{ site.baseurl }}/assets/images/post-programmers/112.png){: .align-center}


### 구현 방식

- BFS를 통해 완전 탐색을 진행해서, 최대 거리 일때 최대 비밀 번호를 구한다.
- `GetMaxPW` 에서 최대 거리 와 최대 비밀 번호 업데이트


### 코드

- 최종 코드는 아래와 같다.


```cpp

const int MAXSIZE = 50;
int graph[MAXSIZE][MAXSIZE] = {};
int dist[MAXSIZE][MAXSIZE] = {};

pair<int,int> Directions[4] = {{1,0},{-1,0},{0,1},{0,-1}};

void solution(int N, int M)
{
    int MaxDist = INT_MIN;
    int MaxPW = INT_MIN;
    for(int i = 0; i < N; i++)
    {
        for(int j = 0; j < M; j++)
        {
            if(graph[i][j] != 0)
            {
                fill(&dist[0][0], &dist[MAXSIZE-1][MAXSIZE], -1);
                pair<int,int> start = {i,j};
                bfs(N,M,start);
                GetMaxPW(N,M,start, MaxDist, MaxPW);
            }
        }
    }
    if(MaxPW == INT_MIN) cout << 0;
    else cout << MaxPW;
}

void bfs(int N, int M, pair<int,int>& start)
{
    queue<pair<int,int>> q;
    q.push(start);
    dist[start.first][start.second] = 0;

    while(!q.empty())
    {
        pair<int,int> curr = q.front();
        q.pop();
        for(auto& dir : Directions)
        {
            pair<int,int> next = {curr.first + dir.first , curr.second + dir.second};
            if(CanGo(N, M, next))
            {
                q.push(next);
                dist[next.first][next.second] = dist[curr.first][curr.second] + 1;

            }
        }
    }
}

bool CanGo(int N, int M, pair<int,int>& pos)
{
    if(pos.first < 0 || N <= pos.first)
        return false;
    if(pos.second < 0 || M <= pos.second)
        return false;
    if(graph[pos.first][pos.second] == 0)
        return false;
    return dist[pos.first][pos.second] < 0;
}

void GetMaxPW(int N, int M, pair<int,int>& start, int& MaxDist, int& MaxPW)
{
    for(int i = 0; i < N; i++)
    {
        for(int j = 0; j < M; j++)
        {
            if(MaxDist < dist[i][j])
            {
                MaxDist = dist[i][j];
                MaxPW = graph[i][j] + graph[start.first][start.second];
            }
            else if(MaxDist == dist[i][j] && MaxPW < graph[i][j] + graph[start.first][start.second])
            {
                MaxPW = graph[i][j] + graph[start.first][start.second];
            }
        }
    }


```
