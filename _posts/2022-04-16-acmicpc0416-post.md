---
title: "[알고리즘] 로봇 청소기"
date: 2022-04-16 21:41:28 -0400
categories: 알고리즘 시뮬레이션 C++
---

![[no-alignment]]({{ site.url }}{{ site.baseurl }}/assets/images/post-programmers/124.png){: .align-center}

![[no-alignment]]({{ site.url }}{{ site.baseurl }}/assets/images/post-programmers/125.png){: .align-center}

### 구현 방식

- 왼쪽 방향으로 간다면 북 -> 서 -> 남 -> 동 순 으로 진행될 것이다.
- 다만, 입력에서 1 : 동 , 3 : 서 이므로, 두개 분기를 나눠 값을 바꿔주자.

### 코드

- 최종 코드는 아래와 같다.


```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int MAXSIZE = 50;

int graph[MAXSIZE][MAXSIZE] = {};
bool visited[MAXSIZE][MAXSIZE] = {};
pair<int,int> Directions[4] = {{-1,0}, {0,-1}, {1,0}, {0,1}};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int N, M, dir;
    cin >> N >> M;

    pair<int,int> start;
    cin >> start.first >> start.second >> dir;

    if(dir == 1) dir = 3;
    else if(dir == 3) dir = 1;

    for(int i = 0; i < N; i++)
    {
        for(int j = 0; j < M; j++)
        {
            cin >> graph[i][j];
        }
    }

    solution(N,M, start, dir);
    return 0;
}


void solution(int N, int M, pair<int,int> start ,int dir)
{
    cout << simulation( N,  M, start, dir);

}

int simulation(int N, int M, pair<int,int>& start, int dir)
{
    int counter = 0;
    pair<int,int> curr, next;
    curr = start;
    bool bCanGo = false;
    while(true)
    {
        if(!visited[curr.first][curr.second])
        {
            visited[curr.first][curr.second] = true;
            counter++;
        }
        bCanGo = false;
        for(int i = 0; i < 4; i++)
        {
            dir = ++dir % 4;
            next = {curr.first + Directions[dir].first, curr.second + Directions[dir].second};
            if(CanGo(N,M,next) && ! visited[next.first][next.second])
            {
                bCanGo = true;
                curr = next;
                break;
            }
        }
		// 4 방면 다 봤는데, 청소 할 수 있는 빈공간이 없던 경우 후진/break 진행
        if(!bCanGo)
        {
            int backDir = back(dir);
            pair<int,int> backPos = {curr.first + Directions[backDir].first , curr.second + Directions[backDir].second};
            if(CanGo(N,M,backPos))
            {
                curr = backPos;
            }
            else
                break;
        }

    }

    return counter;
}

bool CanGo(int N, int M, pair<int,int>& pos)
{
    if(pos.first < 0 || N <= pos.first)
        return false;
    if(pos.second < 0 || M <= pos.second)
        return false;
    if(graph[pos.first][pos.second] == 1)
        return false;
    return true;
}

int back(int dir)
{
    return (dir + 2) % 4;
}

```
